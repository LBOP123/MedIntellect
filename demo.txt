<button id="vqabtn">视觉问答</button>   


// 点击上传图片按钮，触发文件选择
    $("#upload_image").on("click", function () {
        $("#imagefile").click();
    })
    // 监听图片文件选择变化
    $("#imagefile").on("change", function () {
        var files = $(this)[0].files;
        if (files.length === 0) {
            alert("你没有选择文件");
        } else {
            var formData = new FormData($("#upload_image_form")[0]);
            $.ajax({
                url: "/uploadimage",
                type: 'POST',
                data: formData,
                dataType: "JSON",
                contentType: false,
                processData: false,
                cache: false,
                beforeSend: function () {
                    $("#upload_image").attr("disabled", "disabled");
                },
                complete: function () {
                    $("#upload_image").removeAttr("disabled");
                },
                success: function (result) {
                    if (result.status == 200) {
                        $("#imagefile").val("");
                        alert("图片上传成功！");
                        // 将上传的图片显示在聊天窗口中
                        var image_html = '<div class="item item-left">'
                            + '<div class="avatar avatar-bot"></div>'
                            + '<div class="bubble bubble-left">图片上传成功！</div>'
                            + '<img src="' + result.image_url + '" style="max-width: 200px; margin: 10px;">'
                            + '</div>';
                        $('.content').append(image_html);
                        // 滚动条置底
                        var height = $('.content').scrollTop();
                        $(".content").scrollTop(height);
                    } else {
                        alert("上传失败：" + result.message);
                    }
                },
                error: function (jqXHR, textStatus, e) {
                    alert("提交异常：" + e);
                }
            });
        }
    })
    $("#vqabtn").on("click", function () {
        console.log("vqabtn clicked")
        var searchtext = $.trim($('#chattextarea').val());
        if (searchtext == "") {
            alert("请输入您的问题");
            return;
        }
        // 将问题添加到聊天窗口的末尾
        var question_html = '<div class="item item-right">'
            + '<div class="bubble bubble-right">' + searchtext + '</div>'
            + '<div class="avatar avatar-user"></div>'
            + '</div>';
        $('.content').append(question_html);
        // 清空问题文本框
        $('#chattextarea').val('');
        $('#chattextarea').focus();
        // 滚动条置底
        var height = $('.content').scrollTop();
        $(".content").scrollTop(height);
        $.ajax({
            type: "get",
            url: "/vqaanswer",
            data: {
                "id": $("#vqabtn").attr("id"),
                "text": searchtext
            },
            dataType: "json",
            beforeSend: function () {
                $("#vqabtn").attr("disabled", "disabled");
            },
            complete: function () {
                $("#vqabtn").removeAttr("disabled");
            },
            success: function (result) {
                if (result.status == 200) {
                    var answer_html = '<div class="item item-left">'
                        + '<div class="avatar avatar-bot"></div>'
                        + '<div class="bubble bubble-left">' + result.answer + '</div>'
                        + '</div>';
                    $('.content').append(answer_html);
                    // 滚动条置底
                    var height = $('.content').scrollTop();
                    $(".content").scrollTop(height);
                } else {
                    var answer_html = '<div class="item item-left">'
                        + '<div class="avatar avatar-bot"></div>'
                        + '<div class="bubble bubble-left">对不起，我无法回答这个问题。请确保已上传图片。</div>'
                        + '</div>';
                    $('.content').append(answer_html);
                }
            },
            error: function (jqXHR, textStatus, e) {
                alert("提交异常：" + e);
            }
        });
    })

import torch
import torch.nn as nn
from torchvision import models, transforms
from torchvision.models import mobilenet_v2
from PIL import Image
# 定义图片上传请求链接
@csrf_exempt
def uploadimage(request):
    res = {
        'status': 404,
        'text': 'Unknown request!',
        'image_url': ''
    }
    if request.method == 'POST':
        # 获取上传的图片文件
        image_file = request.FILES.get('imagefile')
        if not image_file:
            res['status'] = 400
            res['text'] = '没有选择图片文件'
            return HttpResponse(json.dumps(res), content_type='application/json')
        # 检查文件类型
        allowed_types = ['image/jpeg', 'image/png', 'image/gif']
        if image_file.content_type not in allowed_types:
            res['status'] = 400
            res['text'] = '不支持的图片格式'
            return HttpResponse(json.dumps(res), content_type='application/json')
        try:
            # 创建临时图片目录
            temp_filepath = os.path.join(settings.STATIC_ROOT, 'temp_images')
            if not os.path.exists(temp_filepath):
                os.makedirs(temp_filepath)
            else:
                # 清理临时目录中的所有文件
                for file in os.listdir(temp_filepath):
                    os.remove(os.path.join(temp_filepath, file))
            # 使用固定文件名保存图片
            ext = image_file.name.split('.')[-1]
            filename = f'current_image.{ext}'
            file_path = os.path.join(temp_filepath, filename)
            # 保存图片文件
            with open(file_path, 'wb+') as f:
                for chunk in image_file.chunks():
                    f.write(chunk)
            # 返回图片URL路径
            image_url = os.path.join(settings.STATIC_URL, 'temp_images', filename)
            res = {
                'status': 200,
                'text': '图片上传成功',
                'image_url': image_url
            }
        except Exception as e:
            res = {
                'status': 500,
                'text': f'图片上传失败：{str(e)}',
                'image_url': ''
            }
    return HttpResponse(json.dumps(res), content_type='application/json')
# 定义模型架构
class TinyVQA(nn.Module):
    def __init__(self, vocab_size, ans_size):
        super().__init__()
        self.cnn = mobilenet_v2(weights="DEFAULT")
        for param in self.cnn.parameters():
            param.requires_grad = False
        self.img_proj = nn.Linear(1000, 128)
        self.embed = nn.Embedding(vocab_size, 64)
        self.lstm = nn.LSTM(64, 128, batch_first=True)
        self.classifier = nn.Sequential(
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Linear(128, ans_size)
        )
    def forward(self, img, ques):
        img_feat = self.img_proj(self.cnn(img))
        txt_feat, _ = self.lstm(self.embed(ques))
        combined = torch.cat([img_feat, txt_feat[:, -1, :]], dim=1)
        return self.classifier(combined)
# 加载模型（在全局范围内只加载一次）
checkpoint = torch.load('../tiny_vqa_model.pth')
model = TinyVQA(vocab_size=len(checkpoint['word2idx']), ans_size=len(checkpoint['ans2idx']))
model.load_state_dict(checkpoint['model_state'])
model.eval()
# 获取词汇表和答案映射
word2idx = checkpoint['word2idx']
ans2idx = checkpoint['ans2idx']
idx2ans = {v: k for k, v in ans2idx.items()}
# 图像转换
transform = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])
@csrf_exempt
def vqaanswer(request):
    res = {
        'status': 404,
        'text': 'Unknown request!',
        'answer': '无法回答该问题'
    }
    if request.method == 'GET':
        name = request.GET['id']
        if name == 'vqabtn':
            try:
                # 获取问题文本
                question = request.GET['text']
                if not question:
                    res['status'] = 400
                    res['text'] = '问题不能为空！'
                    return HttpResponse(json.dumps(res), content_type='application/json')
                # 获取当前上传的图片路径
                image_path = os.path.join(settings.STATIC_ROOT, 'temp_images', 'current_image.jpg')
                if not os.path.exists(image_path):
                    res['status'] = 400
                    res['text'] = '请先上传图片！'
                    return HttpResponse(json.dumps(res), content_type='application/json')
                # 处理图片
                image = transform(Image.open(image_path).convert('RGB')).unsqueeze(0)
                # 处理问题文本
                words = question.lower().split()[:10]
                word_ids = [word2idx.get(w, 1) for w in words]
                word_ids += [0] * (10 - len(word_ids))  # 补齐到10个词
                question_tensor = torch.tensor(word_ids).unsqueeze(0)
                # 预测
                with torch.no_grad():
                    output = model(image, question_tensor)
                    _, predicted_idx = torch.max(output, dim=1)
                # 获取预测答案
                predicted_answer = idx2ans[predicted_idx.item()]
                res = {
                    'status': 200,
                    'text': '预测成功',
                    'answer': predicted_answer
                }
            except Exception as e:
                res = {
                    'status': 500,
                    'text': f'预测失败：{str(e)}',
                    'answer': '预测出错'
                }
    return HttpResponse(json.dumps(res), content_type='application/json')